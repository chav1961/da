// 
// Общее замечание - все правила должны быть записаны в одну строку. Если строка слишком длинная,
// можно в конце строки поставить символ '\' и продолжить данные на следующия строках.
// Для обозначения перевода строки, который должен попасть в выходной поток, в строках можно 
// использовать комбинацию '\n'
//

//
// Секция @head - необязательная
// Текст, который может быть добавлен в начало файла с выгруженными данными
// В тексте допустимо использование подстановочный переменных вида ${name}
// В секции @head и @tail доступны только имена из переменных окружения ОС,
// из параметров -Dимя=значение из командной строки java, а также предопределенное имя
// ${timestamp} в формате даты/времени (время запуска приложения)
// 

@head
#
# User 		: ${USERNAME}
# Uploaded	: ${timestamp}  
#  

@prefix rdf: <>

//
// Секция @body - обязательная
// Если секций @head и @tail в файле нет, строку @body можно не писать
//
// Формат задания правил следуюший:
//      шаблон пути XML -> выходной шаблон
//
// Все ${name}, упомянутые в шаблонах пути файла и пути XML, наряду с общими подстановочными переменными, можно использовать для подстановки в выходном шаблоне.
//
// Правила работы с именами следующие:
//
//   - если имя к моменту появления в шаблоне пути уже было определено, то требуется, чтобы элемент пути XML был равен текущему значению данного имени.
//   - если имя к моменту появления в шаблоне пути еще не было определено, то имя считается определенным с данного момента, а его значение становится равным значению элемента шаблона,
//           на который оно ссылается.
//  
// Имя может использоваться либо как часть пути шаблона, либо как имя атрибута тега XML, значение которого надо либо извлечь (если имя еще не определено), либо проверить (если оно уже определено).
//  
// Пример правила:  

@body
RootTag/${tag}/InnerTag[@Attr1=${attr1},@Attr2=${attr2},@Attr3=${attr1},@Attr4="123",@@Attr5=${attr5}]/${content}* -> \ 
		rdf:@{attr1} a rdf:${attr2} . \n \
	.if attr5 ? \n \
		rdf:@{attr1} rdfs:label "${attr5}"@ru . \n \
	.endif \n \
		rdf:@{attr1} rdfs:comment "${content}"@ru .

//
// Правило означает, что если в тексте XML встретится корень RootTag, в который вложен любой тег (его имя при этоми будет присвоено переменной ${tag}, а сама переменная будет определена), 
// в который, в свою очередь, вложен тег InnerTag, и у которого: 
//
//    - имеется обязательный атрибут @Attr1 (его значение будет при этом присвоено переменной ${attr1}, а сама переменная будет определена)
//    - имеется обязательный атрибут @Attr2 (его значение будет при этом присвоено переменной ${attr2}, а сама переменная будет определена)
//    - имеется обязательный атрибут @Attr3, значение которого совпадает со значением атрибута @Attr1 (потому что переменная ${attr1} уже определена, и в ней лежит значение атрибута @Attr1)
//    - имеется обязательный атрибут @Attr4, значение которого равно в точности "123"
//    - может присутствовать атрибут @Attr5 (два знака @@ перед именем означают необязательность атриюбута, переменная ${attr5} будет определена в любом случае, но значения при отсутствии атрибута не получит)
//    - имеется подвешенное под него поддерево (в частном случае, если символ '*' после имени на указан, состоящее только из текста без вложенных тегов - например, фамилии человека)
//
// то данное правило считается выполненным, и по нему будет отработан выходной шаблон.
//
// Выходной шаблон, фактически, представляет собой готовый текст с подстановочными переменными, который будет сформирован в качесвте результата при выполнении данного правила. Помимо собственно шаблона, 
// в нем можно использовать простейший препроцессор. Препроцессор имеет вид .if УСЛОВИЕ .... [.else ....] .endif. В качестве условия допустимо употреблять имя подстановочной переменной без знаков '${' и '}'. 
// Действие препроцесосра аналогично директиве #ifdef языка C. Директивы препроцессора могут быть вложенными.
//


//	
// Секция @tail - необязательная
// Текст, который может быть добавлен в конец файла с выгруженными данными
//

@tail
# the end
